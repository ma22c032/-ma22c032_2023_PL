# -*- coding: utf-8 -*-
"""Power method for large graphs

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_yeXlFDhtyXj2U5Jh1UJ_OWkaZFdBxH3
"""

#Task 1:
#Use the eig function to compute the stationary distribution of the Markov chain from Gamblerâ€™s ruin with p = 0.4 and N = 10

import numpy as np

p = 0.4
N = 10

# Create the transition matrix P
P = np.zeros((N, N))
for i in range(N):
    if i == 0:
        P[i, i] = 1 - p
        P[i, i + 1] = p
    elif i == N - 1:
        P[i, i] = 1
    else:
        P[i, i] = 1 - p
        P[i, i + 1] = p

# Find the stationary distribution using eig
eigenvalues, eigenvectors = np.linalg.eig(P.T)
stationary_distribution = eigenvectors[:, 0] / sum(eigenvectors[:, 0])

#Task 2:
#Compute the PageRank for all states of the Markov chain with N = 10 and different restart probabilities (r = 0.1, 0.01, 0.001, 0.0001).

#Task 3:
#This task asks to compute the PageRank of the ruin state for r = 0.1 and N = 1000. You can attempt to use eig to compute it, but it's likely to become infeasible for large N due to memory constraints.

#Task 4:
#Implement the power method as described and use it to compute the PageRank of the ruin state for r = 0.1 and N = 100000.

#Here's the implementation of the power method for Task 4:
import numpy as np

def powerP(x, aPt, r=0.1, maxn=1000, tol=1e-10):
    for n in range(maxn):
        new_x = (1 - r) * aPt(x) + r / len(x)
        if np.linalg.norm(new_x - x) < tol:
            return new_x
        x = new_x
    return x

# Define the number of states (N) for the small graph
N = 10

# Create the transition matrix P for the small graph
p = 0.4
P = np.zeros((N, N))
for i in range(N):
    if i == 0:
        P[i, i] = 1 - p
        P[i, i + 1] = p
    elif i == N - 1:
        P[i, i] = 1
    else:
        P[i, i] = 1 - p
        P[i, i + 1] = p

# Define a function that applies Pt to a vector for the small graph
def aPt(x):
    return P.T @ x

# Initial probability distribution for the small graph
x0 = np.ones(N) / N

# Example usage for Task 4
result = powerP(x0, aPt, r=0.1)

