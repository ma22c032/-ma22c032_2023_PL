# -*- coding: utf-8 -*-
"""Googleâ€™s PageRank

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15C3ssop_H4o8tIVaaepYWRj68dHvsbP2
"""

import numpy as np
from numpy.linalg import eig, matrix_power, norm

PA = np.array([[1/2, 1/4, 1/4],
[1/3, 1/3, 1/3],
[1/3, 1/3, 1/3]])

[norm(matrix_power(PA.T, n+1) - matrix_power(PA.T, n), 'fro') for n in range(1, 20)]

ew, ev = eig(PA.T)
ew

v = ev[:, abs(ew-1) < 1.e-14]; print(v)

sA = v / v.sum()
sA

matrix_power(PA.T, 1000)

PB = np.array([[0, 1/3, 1/3, 1/3],
[0.9, 0, 0, 0.1],
[0.9, 0.1, 0, 0],
[0.9, 0, 0.1, 0]])

ew, ev = eig(PB.T); print(ew)

# stationary distribution:
v = ev[:, abs(ew-1) < 1.e-14];
sB = v.real / sum(v.real); print(sB)

[norm(matrix_power(PB.T, n) - sB, 'fro') for n in range(300, 305)]

PC = np.array([[0, 1, 0],
[0, 0, 1],
[1, 0, 0]])

ew, ev = eig(PC.T); print(ew)

# stationary distribution:
v = ev[:, abs(ew-1) < 1.e-14].real; sC = v/v.sum(); print(sC)

[norm(matrix_power(PC.T, n+1) - matrix_power(PC.T, n)) for n in range(100,105)]

[print('The %dth power:\n'%i, matrix_power(PC.T, i)) for i in range(300,306)];

A = np.array([[0.1, 0.9],
[0.6, 0.4]])
ew, ev = eig(A)
ew

# Commented out IPython magic to ensure Python compatibility.
import matplotlib.pyplot as plt
# %matplotlib inline
def plotcone(A0, A1, xlim=(0,1.1), ylim=(0,1.), matlabel='$A$',tt='Illustration of convergence of $A^n$'):
  t = np.linspace(0, 3, num=100)
  gridline0 = t[:, np.newaxis] * A0
  gridline1 = t[:, np.newaxis] * A1
  fig = plt.figure(); ax = plt.gca()
  for i in range(20):
      ax.plot(gridline0[:, 0], gridline0[:, 1], 'b')
      ax.plot(gridline1[:, 0], gridline1[:, 1], 'r')
      gridline0 += (1/5) * A1
      gridline1 += (1/5) * A0
  ax.set_xlim(xlim); ax.set_ylim(ylim)
  ax.set_title(tt)
  a0 = ax.arrow(0, 0, A0[0], A0[1], width=0.05, color='blue', alpha=0.3)
  a1 = ax.arrow(0, 0, A1[0], A1[1], width=0.05, color='red', alpha=0.3)
  plt.legend((a0, a1), ('First column vector of '+matlabel, 'Second column vector of '+matlabel), loc='lower right');

M = A.copy()
for i in range(5): # plot the cone between columns for each matrix power
  A0 = M[:, 0]
  A1 = M[:, 1]
  plotcone(A0, A1, matlabel='$A^'+str(i+1)+'$')
  M = M @ A

B = np.array([[0.1, -1.6], # change sign of one entry of A to get B
              [0.6, 0.4]])
plotcone(B[:,0], B[:,1], xlim=(-2.1, 0.5), ylim=(-1.1, 1.1),matlabel='$B$', tt='Noncovergence')
B = B @ B
plotcone(B[:,0], B[:,1], xlim=(-2.1, 0.5), ylim=(-1.1, 1.1),matlabel='$B^2$', tt='Noncovergence')

matrix_power(PA, 1000) # P^1000 for Example A

sA # the stationary distribution for Example A

def pagerank(a, r):
  """ Return pagerank based on adjacency matrix "a" (square matrix
  of 0s or 1s) and given restart probability "r". Use only for small
  dense numpy matrices a. """
  m = a.sum(axis=1)
  dangling = (m==0)
  m[dangling] = 1
  w = (1 / m[:, np.newaxis]) * a
  w[dangling, :] = 1 / a.shape[0]
  p = (1-r) * w + (r / a.shape[0])
  ew, ev = eig(p.T)
  s = ev[:, abs(ew-1) < 1e-15].real
  return s / s.sum()

# 0 1 2 3 4 5 6 7 8 (Adjacency Matrix of the above graph)
A = np.array([[0, 1, 0, 0, 1, 0, 0, 0, 0], # 0
              [0, 0, 0, 0, 1, 0, 0, 0, 0], # 1
              [0, 0, 0, 0, 1, 0, 0, 0, 0], # 2
              [0, 0, 0, 0, 1, 0, 0, 0, 0], # 3
              [0, 0, 0, 0, 0, 0, 1, 0, 0], # 4
              [0, 0, 0, 0, 1, 0, 0, 0, 0], # 5
              [0, 0, 0, 0, 0, 1, 0, 0, 0], # 6
              [0, 0, 0, 0, 0, 1, 0, 0, 0], # 7
              [0, 0, 0, 0, 0, 1, 0, 0, 0]]) # 8

pagerank(A, 0.1)

pagerank(A, 0.01)

pagerank(A, 0.0)

