# -*- coding: utf-8 -*-
"""column space

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1BsioqvyMVEv7sc7k5hoaxVj_97MX0Ur9
"""

#Task 1: Compute the column space of matrix A using QR and SVD factorizations.

import numpy as np
from scipy.linalg import svd, qr

# Define the matrix A
A = np.array([[1, -2, 3, -3], [2, -4, 9, -2], [-3, 6, -9, 9]])

# Using QR factorization to find a basis for column space
Q, R = qr(A, mode='economic')
column_space_basis_qr = Q

# Using SVD to find a basis for column space
U, S, Vt = svd(A)
column_space_basis_svd = U

# Both column_space_basis_qr and column_space_basis_svd contain basis vectors for the column space

#Task 2:
# Check if the QR basis vectors can be formed from the SVD basis vectors
qr_in_svd = all(np.all(np.isclose(Q[:, i], U @ U.T @ Q[:, i])) for i in range(Q.shape[1]))

# Check if the SVD basis vectors can be formed from the QR basis vectors
svd_in_qr = all(np.all(np.isclose(U[:, i], Q @ Q.T @ U[:, i])) for i in range(U.shape[1]))

# If qr_in_svd and svd_in_qr are both True, the bases span the same space
if qr_in_svd and svd_in_qr:
    print("The column spaces are the same.")
else:
    print("The column spaces are different.")

#Task 3:Compare the speed of these methods for a 500x500 random matrix.
import time

# Generate a random 500x500 matrix
random_matrix = np.random.rand(500, 500)

# Measure the time for QR factorization
start_time_qr = time.time()
Q, R = qr(random_matrix, mode='economic')
end_time_qr = time.time()
qr_time = end_time_qr - start_time_qr

# Measure the time for SVD
start_time_svd = time.time()
U, S, Vt = svd(random_matrix)
end_time_svd = time.time()
svd_time = end_time_svd - start_time_svd

if qr_time < svd_time:
    print("QR factorization is faster.")
else:
    print("SVD is faster.")