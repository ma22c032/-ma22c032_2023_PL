# -*- coding: utf-8 -*-
"""Numpy blitz

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1u6L1ehYPkDrfX8ZJ6GPem4uq4BBNrD7J
"""

!pip install gitpython

import numpy as np
import math

A = [0.1, 1.3, 0.4, 0.5] # list
a = np.array(A) # numpy array
type(a), type(A)

a.dtype # a's common element type (A.dtype is undefined!)

2*a

2*A

n = 100000
x = np.linspace(0, 2*np.pi, n)

# Commented out IPython magic to ensure Python compatibility.
# list comprehension
# %timeit y = [math.sin(x[i]) * math.exp(-x[i]) for i in range(n)]
# use numpy ufuncs
# %timeit y = np.sin(x) * np.exp(-x)

def f(v): # apply f to one scalar value v
  return math.sin(v) * math.exp(-v)

vectorizedf = map(f, x) # apply same f to a vector of values x

F = np.vectorize(f) # F can be applied to a array x

# Commented out IPython magic to ensure Python compatibility.
# use map
# %timeit y = list(map(f, x))
# use numpy's vectorize
# %timeit y = F(x)
# use numpy's ufunc
# %timeit y = np.sin(x) * np.exp(-x)

# Commented out IPython magic to ensure Python compatibility.
# %timeit for x in range(1000000): x**3
# %timeit for x in np.arange(1000000): x**3

a = np.random.randint(0,9,5)
a

a[::]

a[-3:]

a[-1], a[len(a)-1]

a[-4:-1:2]

slice = range(-4,-1,2) # Think of b:e:s specification as a range.
a[-4:-1:2], a[slice] # In older versions, a[slice] may not work
                     # but will work with slice=arange(-4,-1,2).

a = np.array([1,2,3])
b = np.array([3,4,5,6])

a = b
a[0] = 1
a

b

a = np.array([1,2,3]) # This is Object1 and "a" is a name for it.
b = np.array([3,4,5,6]) # This is Object2 and "b" is a name for it.

id(a), id(b)

a = b # a is no longer a name for Object1, it is now a name for Object2.

id(a), id(b)

a = np.array([1,2,3]) # Object1
b = np.array([3,4,5,6]) # Object2
a = b.copy() # Copies Object2, and binds a to the copy
a[0] = 2 # Only the copied (new) object is changed

a, b

Amat = [[1,2],
[3,4]]
Amat

amat = np.array(Amat)
amat

type(A), type(a)

2*Amat

2*amat

amat

amat * amat

import sys
print(sys.version) # check if you have version >= 3.5 before trying @

amat @ amat

np.dot(amat, amat) # dot(A,B) = matrix A multiplied by matrix B

amat.dot(amat)

amat**2 # not equal to matrix power !!

np.linalg.matrix_power(amat, 2)

A = np.array([[7, 8, 5, 1], [2, 5, 5, 2], [9, 6, 8, 9]])
A

A[1, :], A[:, 2]

A[:3:2, :3]

M = np.array([[7, 8, 5, 1], [2, 5, 5, 2], [9, 6, 8, 9]])
M

M.reshape(2, 6) # Just a different view of the same data

M.ravel() # The 1D data of M in row-major ordering

A = np.array(M, order='F')
A

A.ravel(order='A') # A's internal ordering is Fortran style

M.ravel(order='A') # M's internal ordering is default C-style

N = np.arange(25).reshape(5,5)
N

mask = (N>7) & (N<18)
mask

N[mask]

i, j = np.where(mask) # Returns i and j indices where mask[i,j] is True.
i, j # 1st True value of mask is at i[0],j[0],
# 2nd True value of mask is at i[1],j[1], etc.

data = np.random.randint(low=0, high=10, size=30) # 1D array

T2 = np.reshape(data, (6, 5)) # 2D array
T2

T3 = np.reshape(data, (2, 3, 5)) # 3D array
T3

print('T3 is a ', T3.ndim, 'dimensional array of shape ', T3.shape)
print('T2 is a ', T2.ndim, 'dimensional array of shape ', T2.shape)
print('data is a ', data.ndim, 'dimensional array of shape ', data.shape)